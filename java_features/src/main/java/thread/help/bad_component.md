### Bad component defaults

- [instructor] 

- In the serverless and microservice world, it's  awfully tempting to just bootstrap a project, plunk your code in it, and it's runtime baby, or is it? See in the world of convention over configuration and "sensible defaults" We allow these frameworks to make good-intentioned assumptions on our behalf. Sometimes those assumptions don't pan out in our favor. No, what they will do is quietly slow down the application death by a thousand cuts. These types of bottlenecks are particularly nefarious because they don't manifest as a bright flashing red sign screaming bottleneck here. No, it's a bunch of quiet slowdowns peppered all over the application like a lot of R&B music. In some scenarios, the defaults won't do. Take garbage collection for example. The JVM makes some assumptions on your behalf based on the amount of RAM a detects on your machine. By default, it'll attempt to reserve about 25% of your RAM. 1/4 of the available RAM may sound like a lot, but because of the abundance of RAM and the many deployment options available in today's world, this default might not be the best for you. RAM is a lot cheaper these days And if you're not running your application in a shared resource constraint environment, you could probably afford to increase this default allocation to minimize the risk of frequent garbage collections, which as we've covered could be the source of both throughput and latency problems. You can tune your heap size allocation with these configuration parameters introduced with JDK 8. Logging by default is usually synchronous, depending on your application's needs. You're likely going to get a lot of benefit by configuring your applications logging to become asynchronous. Log back gives a very good introduction to the subject and you can find the same for Log4j as well. For many use cases, you can radically improve both the throughput and latency of the application with asynchronous logging because your code doesn't have to block while logging. Log4j actually provides a couple of options outside of the default appender that you can use to reduce the latency associated with logging depending on your situation. Even without some fancy logging appender, choosing to not log to the console or standard out can noticeably improve the latency around logging. Consider instead just piping all of your log output to a log file and streaming from that log file instead. Looking at the world famous Spring Boot platform, let's talk about database connection pooling. Unless you're using two specific Spring Boot starters, your Spring Boot app will select Apache's Tomcat's data source pooling by default. The Spring Boot documentation states explicitly though, they recommend the Hikari database connection pool manager over Tomcat's. It's very probable that the Spring team will rectify this in the near future by making Hikari the default across all Spring Boot starters. Now some of your alarm bells may be going off, hey, this all sounds like a lot of premature optimization. And to that I'll say these are things that should be done as a matter of course. You should start out your applications changing some of these defaults. You should only leave the defaults in only if you specifically need them to be that way, or you're already comfortable with the stock framework performance. Again, troubleshooting performance issues is part art and part science with a healthy dose of gray area. You're better off starting with some of the common sense alternatives to default configurations in some scenarios. Consider it a process of elimination, remove some of the more generic and widespread blocking sources so you can focus on a smaller area of suspicious blockers.