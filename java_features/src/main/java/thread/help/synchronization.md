## Synchronization and locking

- [Instructor] Synchronization and locking are fundamental to programming and computing in general, and they can both get pretty complicated. So we're not going to go into too much detail of how either of them work per se. Synchronization in Java is a mechanism that you use to maintain orderly, one-by-one access to a field, a method, or data structure. A lock is a component that you use to maintain that order in the synchronization process. Now, close your eyes and imagine a restaurant, busy kitchen and all that. It has exactly one table set for one guest. But there's a line of customers waiting outside. The only way to maintain orderly access to that single table is to provide only one door. Everyone has to wait their turn. Can you see how this can quickly become a problem? In this analogy, the guests waiting outside are threads. The restaurant is the JVM. The table, a method or a data structure. This is the story of a throughput problem in the making. Here's what that looks like in code. So when you look over here at line 35, I've got this public static synchronized method named scramble with synchronizer. By adding the synchronized keyword here on line 35 I'm stipulating that only one thread can access this method at a time. There are other ways to express synchronization but the effect is still the same. Let's now talk about locks. Think of a lock as a component that gives its holder the access to a different component. From our restaurant scenario, the lock would be the single chair at the table that's set for one. If you can't sit down, you can't eat. It doesn't even matter if you somehow manage to get into the restaurant. For a thread to access an object or data structure it must first obtain the lock associated with that object. There's a cost associated with obtaining the lock on an object. For each thread that tries to obtain the lock associated with that object there's a bunch of work the CPU needs to do all hidden from your view as the user or program. If multiple threads are trying to obtain the same lock the overhead is multiplied. Think of it this way. It's easier for guests at our hypothetical restaurant to just walk in, sit down and enjoy their meal versus three of them going into the restaurant at the same time and brawling for the single available seat. Even more insidious are synchronization issues that you didn't consciously introduce into your code. Many data structures and components in Java use synchronization under the hood. Take for example, you know, from the all too familiar system.out.print line frame. Go over to my code here and let's say I just want to print out my name. Print line and my name is Tayo. The print line method, as you can see here on line 36, is implicitly synchronized. Java allows only one access to system.out via the print line method. So when you pepper your code with system.out.print line in the name of "logging" you've quietly introduced many small bottlenecks into your code. Multiple unrelated threads are going to fight each other for access to the single standard out components or wait their turn. Standard JDK classes and data structures also use synchronization. The random vector and string buffer classes are some of the more popular offenders. In general, when a class advertises itself as thread-safe by default you should pay close attention to its behavior under load. So what am I saying here? Synchronization can be costly. Try to design around it if you can. No, it's not premature optimization, it's usually avoidable overhead that you could do without using good design patterns, the right data structures, or classes that don't depend on synchronization to work properly. Finally, this cohort of multi-threading problems is hard to detect by just reading your code. You're more likely to detect them with tools like profilers and monitoring agents. So please, don't beat yourself up when your management throws some code at you and expects you to fish out this sort of performance problem on the spot. That's not how this works. How does it work? Hang tight and I'll show you.