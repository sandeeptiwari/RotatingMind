Java stream issues
Selecting transcript lines in this section will navigate to timestamp in the video
- [Instructor] Despite your best efforts, multithreading sometimes just doesn't work out as described. Now the JDK has been making it increasingly easy to write multithreaded applications with a lot of convenience classes and utilities for managing threads. With Streams in Java, it's now easier than ever to parallelize operations on data. A quick refresher on Java Streams. Java streams are an efficient mechanism for processing data. The data can be fed or streamed in from a data source like a collection, an operation, or even some IO resource. So in general, Java streams are immutable. They are lazily evaluated, and they support cheap parallelism. And you can write with them in a fluent API supported by lambda expressions. Now, let's start with one of my favorite bits of slightly misleading advertising: the parallelism in Java Streams. So here on line 60, I have my scramble with stream method that creates a stream using the stream method off of an array list of strings supplied. You see that here on line 61. When you pop over here to line 67, it's largely the same code, but now with this additional method called parallel streams. So from here on line 61, I created a regular Java stream using the stream method, and I'm using the parallel stream method here on line 68 to create a stream on which I can operate on parallelly. With this one method here called parallel stream on line 68, I've indicated that the items being streamed out of this list should be processed in parallel. So everything after this parallel stream method will happen in a separate thread. And that should be the end of that. Well, surprise, it's possible to get even worse performance from parallelizing the stream operation. First rule of thumb, if for some reason you don't have multiple CPUs or cores available to you and you try to use parallel streams, you might not get the performance boost you're looking for. This can happen very easily in a virtualized or containerized environment. Docker, for example, will allow you to limit the amount of cores available to the runtime. That goes double for most cloud environments. Know your hardware. More CPU's will improve the benefits of parallel processing. Next, you're likely to introduce a latency issue if you use the parallelism or concurrency for small units of work. Under the hood, there's a bunch of work that goes into supporting parallel processing of streams. For small units of work, the overhead is just not worth it. So don't go parallel for processing a list of, say, four items, for example. How about the source of data? See, parallelizing streams works best when you have a finite data source. To get the best results, you shouldn't attempt to multithread over a source of data that's constantly being added to or increasing in size. Now, on a more general note, the size of the individual data items you're working on and the complexity of the operations will also affect the benefits you can obtain from parallelizing a Java stream. Now this I'll admit. This is straying into the premature optimization territory. So don't fret over this sort of problem for now. In general, you just want to start out with a single thread and only multithread on a stream when there's observable improvement benefits. Finally, we have what I consider slow poison. Parallel streams draw threads from a single thread pool provided by the JVM. So when you have these two methods here on line 67, I have scrambled with parallel stream and then on line 73 I've got scramble sync scramble list of words; both of them use parallel streams. When you have these two methods or some incarnation of them, if both methods are invoked concurrently by different threads, let's say both methods serve individual requests from two different years, both of them are drawing from the same single pool of threads. So it's easily conceivable that if either one of these methods takes too long or does some complex calculation and it's hogging all the threads, it can starve your entire application of available threads to service requests. So be very wary when you're going parallel. This is actually a weakness with the Java streaming API, by not letting you pass in custom thread pools fit for size and the purpose of your operation. So to recap, parallel Java streams are not for small workloads. Do not parallelize infinite data sources. Only parallelized data sources that you know you're done modifying. You get the best benefits from parallelizing on a multicore machine. You need to have multiple CPUs to get the best out of parallel streams. Bottom line, tread carefully when writing multithreaded code.